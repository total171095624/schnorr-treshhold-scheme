\chapter{Подпись Шнорра}

Здесь и далее мы используем постановку задачи дискретного логарифмирования на эллиптической кривой. Будем считать \textit{q} достаточно большим простым числом, а \textit{G} и \textit{H} генераторами подгрупп порядка \textit{q} на эллиптической кривой \textit{E}. Мы предполагаем, что кривая \textit{E} выбрана так, что проблема дискретного логарифмирования вычислительно трудна в подгруппе, порождённой \textit{G}, то есть невозможно за разумное время вычислить такое \textit{d}, что $G = dH$.  

\section{Схема разделения секрета Шамира}

В работе \cite{KG} Шамир ставит перед собой задачу поделить секрет \textit{s} на \textit{n} частей так, чтобы 
\begin{itemize}
    \item знание любых \textit{k} или более частей $s_i$ позволяло легко вычислить s;
    \item знание любых $k-1$ или менее частей $s_i$ оставляло \textit{s} неопределённым в том смысле, что все его возможные значения равновероятны.
\end{itemize}

Полученный алгоритм называется (\textit{k}, \textit{n}) пороговой схемой. Полученная схема базируется на интерполяционных многочленах Лагранжа и выглядит она следующим образом:

Пусть $s \in Z_q$, $n < q$, тогда дилер выбирает случайный многочлен $f$ степени не более, чем $k-1$ на полем $Z_q$, такой, что $f(0) = s.$ Тогда каждый участник в качестве своего кусочка получает $s(i) = f(i)$.  

Существует ровно один многочлен степени не более, чем $k - 1$, удовлетворяющий $f(i) = s_i$ для \textit{k} значений \textit{i}. Таким образом любая коалиция $\mathcal{P}$ из \textit{k} человек может восстановить многочлен $f$ путём интерполяции Лагранжа:

$$ f(u) = \sum_{i \in \mathcal{P}}f(i)\omega_i(u), \text{ где } \omega_i(u) = \prod_{\substack{i \in P \\ j \neq i}} \frac{u - j}{i - j} \text{ mod q.} $$

Так как $s = f(0)$, коалиция $\mathcal{P}$ может восстановить секрет следующим образом:

$$ s = f(0) = \sum_{i\in\mathcal{P}}f(i)\omega_i, \text{ где } \omega_i = \omega_i(0) = \prod_{\substack{i \in P \\ j \neq i}} \frac{j}{j - i} \text{ mod q.}$$

Каждое $\omega_i \neq 0$ и может быть легко вычислено из открытой информации. $k - 1$ участника для восстановления не хватит, так как иначе им не удастся найти свободный член многочлена $f$, потому что он с равной вероятностью может принимать любое из своих значений.

\section{Проверяемое разделение секрета Педерсена}

Схема проверяемого разделения секрета нужна, чтобы предотвратить жульничество со стороны дилера. В этой схеме каждый участник может проверить свою часть секрета. Если дилер поделился неверным секретом, это будет обнаружено. В работе \cite{VSS} Педерсен представил свой варинант подобной схемы. Выглядит она следующим образом.

Предположим, что дилер имеет секрет $s \in Z_q$ и случайное число $s' \in Z_q$, и определяется парой чисел (\textit{s}, \textit{s'}) через открытую информацию $C_0 = sG + s'H.$ Тогда секрет \textit{s} может быть разделён между пользователями так:

\begin{enumerate}
    \item Дилер выбирает случайные многочлены
    $$ f(u) = s + f_1u + ...+f_{t-1}u^{t-1} \text{ и } f'(u) = s' + f'_1u + ... + f'_{t-1}u^{t-1}$$
    где $s, s', f_t, f'_t \in Z_q$ для $t \in \{1, ... , k-1\}$. Подсчитывает ($s_i, s'_i$) = ($f(i), f'(i)$) для $i \in \{1, ..., n\}$.

    \item Дилер секретно рассылает участникам пары $(s_i, s'_i)$.

    \item Дилер предъявляет значения $C_t = f_tG + f'_tH$ for $t \in \{1, ..., k-1\}$.
\end{enumerate}

\begin{enumerate}
    \item Каждый участник проверяет, что 
    \begin{equation}\label{check}
        s_iG + s'_iH = \sum_{t=0}^{k-1}i^tC_t. 
    \end{equation}
     Если проверка провалилась, участник подаёт жалобу на дилера.
     \item От каждой жалобы от \textit{i}-го участника дилер может защитить себя предъявив значения $f(i), f'(i)$, удовлетворяющие (\ref{check}).
     \item Отказываемся от дилера, если
     \begin{itemize}
         \item На шаге 1 он получил хотя бы \textit{k} жалоб;
         \item На шаге 2 он ответил на жалобу значениями, не удовлетворяющими (\ref{check}).
     \end{itemize}

     Опираясь на вычислительную сложность проблемы дискретного логарифма на эллиптическй кривой, Педерсен доказал, что любая коалифция из менее, чем $k$ участников не сможет получить никакой информации о секрете.
\end{enumerate}

\section{Генерация случайного секрета для криптосистем, опирающихся на проблему дискретного логарифма}

Приведём схему генерации случайного секрета, описанную в работе \cite{Gen}.

Предполагаем, что доверенный дилер случайным образом выбирает числа $r, r'$, публикует $Y = rG$ и затем делит $r$ между участниками процесса с помощью схемы Педерсена. Мы же хотим исключить из протокола дилера, сделать это можно следующим образом.\\

\textit{Каждый участник протокола $P_i$ действует так:}

\begin{enumerate}
    \item Каждый $P_i$ случайным образом выбирает $r_i, r'_i \in Z_q$ и действует как дилер в соответствии со схемой Педерсена. Пусть в качестве случайных многочленов выступают
    $$ f_i(u) = \sum_{t=0}^{k-1}a_{it}u^t , f'_i(u) = \sum_{t=0}^{k-1}a'_{it}u^t,$$ где $a_{i0} = r_i, a'_{i0} = r'_i$, тогда опубликованные величины примут значения $C_{it} = a_{it}G + a'_{it}H$ для $t\in\{0, ...,k-1\}$
    \item Пусть $H_0$ - подмножество игроков не уличённых в жульничестве на шаге 1. Тогда величина $r$, распространяемая в качестве секрета не может быть вычислена ниодним из участников, но при этом она равна $\sum_{i \in H_0}r_i$. Каждый $P_i$ вычисляет значение своей части секрета $s_i = \sum_{j \in H_0}f_j(i)$ mod q и величину $s'_i = \sum_{j \in H_0}f'_j(i)$ mod q.
    \item Представляем Y в виде $Y = \sum_{j \in H_0}r_jG$. Каждый участник из $H_0$ проверяет $Y_i = s_iG$ в соответсвии со схемой Фелдмана \cite{Fel}:
    \begin{enumerate}[label=\alph*)]
        \item Каждый участник $P_i$ для $i \in H_0$ вскрывает $A_{it} = a_{it}G$ для $t \in \{0, ...,k-1\}$. 
        \item Каждый $P_j$ проверяет значения вскрытые другими участниками из $H_0$. Точнее, для каждого $Pi$, $i \in H_0$ $P_j$ проверяет выполняется ли равенство
        \begin{equation}\label{second}
            f_i(j)G = \sum_{k=0}^{t-1} j^k A_{ik}.
        \end{equation}
        Если проверка провалилась для индекса $i$, $P_j$ подаёт жалобу на участника $P_i$ путём предъявления величин $f_i(j), f'_i(j)$, удовлетворяющих (\ref{check}), но не удовлетворяющих (\ref{second}).
        \item Для участников  $P_i$, кто получил как минимум одну обоснованную жалобу, например, значения удовлетворяющие (\ref{check}), но не удовлетворяющие (\ref{second}), остальные участники производят реконструкцию фазы схемы Педерсена, чтобы посчитать $r_i, f_i, A_{it}$ для $t \in \{0,...,k-1\}$. Т.е. каждый участник раскрывает своё значение $r_i$ и выбирает новое, удовлетворяющее (\ref{check}). Все участники из $H_0$ полагают $Y_i = r_iG$. 
    \end{enumerate}
    
\end{enumerate}

\section{Подпись Шнорра}

В работе \cite{Schnorr} Шнорр представил следующий вариант выработки подписи. Пусть ($x, Y$) - ключевая пара пользователя, \textit{m} - сообщение, $h(\cdot)$ - необратимая хэш-функция, а $G$ - точка эллиптической кривой, порождающая подгруппу порядка $q$. Тогда пользователь генерирует подпись Шнорра сообщения $m$ в соответствии со следующим алгоритмом:

\begin{enumerate}
    \item Случайным образом выбирает $e \in Z_q$
    \item Вычисляет $V = eG$
    \item Вычисляет $\sigma = e + h(m||V)x$ mod q
    \item Предполагает, что подписью сообщения $m$ будет ($V, \sigma$)
\end{enumerate}

Пара ($V, \sigma$) действительно будет подписью сообщения $m$, тогда и только тогда, когда $\sigma \in Z_q$ и $$ \sigma G = V + h(m||V)Y. $$

Также в \cite{Schnorr} Шнорр, используя лемму о разветвлении, показывает, что задача <<единичная подделка>> в схеме ROM по сложности сопоставима с задачей дискретного логарифмирования в подгруппе, порождённой $G$. 
  
\chapter{Пороговая подпись Шнорра}

Схема подписи Шнорра широко используется в современном мире, в том числе в белорусских стандартах. Она хороша тем, что легко преобразуется в пороговую, то есть любые $t$ из $n$ участников смогут вырабатывать подпись, используя личные части ключа. Мы же рассмотрим две важные реализации и в последствии сравним их. 

\section{Реализация Стинсона и Стробла}

Реализация Стинсона и Стробла \cite{SS} является классическим примером надёжной схемы, т.е. если все $t$ участников исправно следуют протоколу, то протокол гарантированно завершится без ошибок, даже если подмножество из не более, чем $n-t$ участников скомпроментировано. 

Данная конструкция требует не менее 4 тактов для совершения подписи (учитывая, что все участники ведут себя хорошо): три такта для генерации ключа (см. 1.3) и один такт чтобы раздать секреты и выработать групповую подпись. Каждый такт обязует всех участников обменяться данными со всеми.

\subsection{Протокол}

Протокол состоит из двух частей: генерации ключа и выработки подписи. Пусть $P_1, P_2, ... , P_n$ множество подписантов, $G$ - генератор подгруппы порядка $q$ точек эллиптичекой кривой.

\subsubsection{Протокол генерации ключа}

Все $n$ подписантов должны скооперироваться для генерации открытого ключа, далее секретный ключ делится между всеми $P_j$. Они генерируют случайный секрет в соответсвии с протоколом из пункта 1.3. Пусть на выходе получилось:

$$ (\alpha_1, ... , \alpha_n) \xleftrightarrow{(t, n)} (x|Y, b_kG, H_0), k\in \{1, ...,t-1\}.$$

Для любого $j \in H_0$, $\alpha_j$ - часть секрета, принадлежащая участнику $P_j$, которая в дальнейшем будет использоваться для выработки ключевой пары $(x, Y)$, где $x$ - личный ключ, а $Y$ - открытый.

\subsubsection{Протокол выработки подписи}

Пусть $m$ - сообщение, а $h(\cdot)$ - необратимая хэш-функция. Предположим, что  $H_1 \subseteq H_0$ множество индексов участников, которые хотят выработать подпись. Тогда они должны следовать следующему протоколу:

\begin{enumerate}
    \item Если $|H_1| < t$, стоп. В противном случае, подмножество $H_1$ генерируют случайный секрет по схеме из пункта 1.3. Пусть на выходе получилось:

    $$ (\beta_1, ... , \beta_n) \xleftrightarrow{(t, n)} (e|V, c_kG, H_2), k\in \{1, ...,t-1\}.$$

    \item Если $|H_2| < t$, стоп. В противном случае, каждый $P_i$, $i \in H_2$ раскрывает

    $$ \gamma_i = \beta_i + h(m||V)\alpha_i .$$

    \item Каждый $P_i$, $i \in H_2$ проверяет, что

    \begin{equation}\label{verify}
        \gamma_jG = V + \sum_{k=1}^{t-1}c_kj^kG + h(m||V) \Big(Y + \sum_{k=1}^{t-1}b_kj^kG \Big) \text{ } \forall j\in H_2.
    \end{equation}

    Пусть $H_3$ - множество индексов участников не уличённых в жульничестве на шаге 3.

    \item Если $|H_3| < t$, стоп. В противном случае, каждый $P_i$, $i \in H_3$ выбирает произвольное подмножество $H_4 \subseteq H_3$ с $|H_4| = t$ и вычисляет $\sigma$, удовлетворяющее $\sigma = e + h(m||V)x$, где

    $$ \sigma = \sum_{j \in H_4}\gamma_j\omega_j \text{ и } \omega_j = \prod_{\substack{l \in H_4 \\ l \neq j}}\frac{l}{l - j}.$$

    Подпись это $(\sigma, V)$. Подпись может быть проверена так же, как и в оригинальной схеме Шнорра: $ \sigma G = V + h(m||V)Y \text{ и } \sigma\in Z_q .$
\end{enumerate}

\subsection{Корректность}

Мы хотим показать, что подпись $\sigma$, выработанная на шаге 4 - это на самом деле подпись Шнорра $m$, другими словами, $\sigma G = e + h(m||V)x \text{ } mod \text{ } q$. Пусть $F_1$ - случайный полином из протокола генерации ключа $(\alpha_i = F_1(i), i \in H_0)$, а $F_2$ - многочлен полученный на шаге 1 ($\beta_i = F_2(i), i\in H_1$). Более того, пусть $F_3 := F_2 + h(m||V)F_1$. Поскольку $\gamma_i = F_3(i), i\in H_3$, из формулы интерполяции Лагранжа следует, что участники вычисляют $\sigma = F_3(0)$. Мы можем рассуждать следующим образом:

$$ \sigma = F_3(0) = F_2(0) + h(m||V)F_1(0) = e + h(m||V)x. $$

\subsection{Надёжность}

Мы хотим показать, что, если меньше, чем $t$ подписантов скомпроментирваны, схема всегда вырабатывает корректную подпись. Мы предполагаем, что $t \leq \frac{n}{2}$. 

Из надёжности протокола генерации секрета следует, что каждый честный участник $P_i$ вычисляет корректные $\alpha_i, \beta_i, \gamma_i$. Тогда остаётся хотя бы $t$ честных участников, которые могут корректно проверить $\gamma_i$, подставив его в \ref{verify}, это прямиком следует из того, что честные подписанты всегда осуществляют проверку корректно.  

\subsection{Безопасность}

Пороговая подпись Шнорра безопасна, так как задача "единичная подделка" в схеме ROM \cite{ROM} для неё сопоставима по сложности с задачей дискретного логарифмирования в подгруппе, порождённой $G$. Для этого в \cite{SS} вводится противник $A_{DistSchnorr}$ и доказывается, что если он умеет атаковать пороговую подпись, то он умеет атаковать и обычную подпись Шнорра, и наоборот. Для этого используется симулятор SIM, который играет роль честного подписанта. 

\begin{defenition}
    Предположим, что $H_0$ - подмножество участников вырабатывающих секрет для входных данных ($q, G$) и получающих на выходе $Y$. Пусть $\tilde{A}$ - противник, который может скомпроментировать не более $t-1$ подписанта. Пусть $view(\tilde{A}, G, q, Y)$ определяет кругозор противника для этого протокола. Пусть $VIEW(\tilde{A}, G, q, Y)$ - случайная величина порождённая $view(\tilde{A}, G, q, Y)$.
\end{defenition}

\begin{lemma}
    Для любого полиномиального вероятностного алгоритма существует противник $\tilde{A}$ и полиномиальный симулятор SIM, который может посчитать случайную величину $SIM(G, q, Y)$,  
\end{lemma}

\begin{defenition}
    Пусть $A_{NormSchnorr}$ вероятностный алгоритм, соответсвующий противнику, который может спросить подписанта о правильной подписи. Назовём $A_{NormSchnorr}(G, q, Y)$ случайную величину, отвечающую вероятности события, что $A_{NormSchnorr}$ задаёт вопросы ($m_1, m_2, ...$) и получает в ответ ($\tilde{m}, \tilde{\sigma}, \tilde{V}$) (при исходных данных ($G, q, Y$)). Вероятность вычисляется по всем возможным ипостасям $A_{NormSchnorr}$ и подписантов. 
\end{defenition}

\begin{defenition}
    Пусть $A_{DistSchnorr}$ полиномиальный вероятностный алгоритм противника, который может скомпроментировать до $t-1$ подписанта. Он также может иметь $t$ или больше произвольных участников вырабатывающих подпись по его запросу. Обозначим за $A_{DistSchnorr}(G, q|Y)$ случайную величину, отвечающую вероятности события, что $A_{NormSchnorr}$ задаёт вопросы ($m_1, m_2, ...$) (при исходных данных ($G, q$) и в конце получает ($\tilde{m}, \tilde{\sigma}, \tilde{V}$) при условии, что протокол выработки ключа вернул $Y$. 
\end{defenition}

\begin{theorem}
    Для любого противника $A_{NormSchnorr}$ против $D_{NormSchnorr}$ (обозначает схему Шнорра), существует противник $A_{DistSchnorr}$ против $D_{DistSchnorr}$ (обозначает пороговую схему Шнорра), такой что

    $$ Pr[A_{DistSchnorr}(G, q|Y) = (m_1, ...,(\tilde{m}, \tilde{\sigma}, \tilde{V}))] = $$
    $$Pr[A_{NormSchnorr}(G, q, Y) = (m_1, ...,(\tilde{m}, \tilde{\sigma}, \tilde{V}))] $$
\end{theorem}

\begin{theorem}
    Для любого противника $A_{DistSchnorr}$ против $D_{DistSchnorr}$ (обозначает схему Шнорра), существует противник $A_{NormSchnorr}$ против $D_{NormSchnorr}$ (обозначает пороговую схему Шнорра), такой что

    $$ Pr[A_{DistSchnorr}(G, q, Y) = (m_1, ...,(\tilde{m}, \tilde{\sigma}, \tilde{V}))] = $$
    $$Pr[A_{NormSchnorr}(G, q|Y) = (m_1, ...,(\tilde{m}, \tilde{\sigma}, \tilde{V}))] $$
\end{theorem}

\section{FROST}

FROST или Flexible Round-Optimized Schnorr Threshold scheme \cite{FROST} - классический пример ненадёжной схемы, то есть мы жертвуем надёжностью в угоду эффективности, а значит любая попытка жульничества со стороны подписантов приводит к прерыванию алгоритма. Также данный протокол хорош тем, что позволяет подписантам действовать асинхронно или даже находится оффлайн.

Для выработки подписи с помощью FROST требуется всего два такта, а для оптимизированного протокола вообще один, но понадобится стадия предварительной обработки.

\subsection{Протокол}

\subsubsection{Протокол генерации ключа}

Протокол генерации ключа в схеме FROST строится на протоколе Педерсена (см. 1.3), но FROST дополнительно требует каждого участника подтвердить их знание секрета $a_{i0}$ предоставив доказательство с нулевым разглашением по схеме Шнорра \cite{ZKP}. Это нужно, чтобы предотвратить атаку с неверным ключом.
\\
\\
\textbf{Такт 1} 
\begin{enumerate}
    \item Каждый участник $P_{i}$ выбирает $t$ случайных значений $(a_{i0},\ldots,a_{i(t-1)})$ $\stackrel{{\boldsymbol{\$}}}{{\leftarrow}}$ $\mathbb{Z}_{q}$ и использует эти значения в качестве коэффициентов для определения полинома степени $t-1$: 
    $$f_{i}(x)=\sum_{j=0}^{i-1}a_{ij}x^{j}.$$

    \item Каждый $P_{i}$ вычисляет доказательство знания соответствующего секрета $a_{i0}$, вычисляя $\sigma_{i}=(R_{t},\mu_{t})$, так что $k\stackrel{{\boldsymbol{\$}}}{{\leftarrow}}\mathbb{Z}_{q}$, $R_{t}=g^{k}$,
    $c_{t}=H(t,\Phi,g^{a_{0}},R_{t})$, $\mu_{t}=k+a_{i0}\cdot c_{t}$, где $\Phi$ — контекстная строка для предотвращения атак повторного воспроизведения.

    \item Каждый участник $P_{i}$ вычисляет публичное обязательство $\vec{C_{i}}=(\phi_{i0},\ldots,\phi_{i(t-1)})$, где $\phi_{ij}=g^{a_{ij}}$, $0\leq j\leq t-1$

    \item Каждый $P_{i}$ транслирует $\vec{C_{i}},\sigma_{i}$ всем остальным участникам.

    \item Получив $\vec{C_{\ell}},\sigma_{\ell}$ от участников $1\leq\ell\leq n$, $\ell\neq i$, участник $P_{\ell}$
    проверяет $\sigma_{\ell}=(R_{\ell},\mu_{\ell})$, прерывая работу в случае ошибки, проверяя $R_{t}\stackrel{{\text{?}}}{{=}}g^{\mu_{t}}\cdot\phi_{\ell0}^{-\sigma_{\ell}}$, где $c_{\ell}=H\left(\ell,\Phi,\phi_{\ell0},R_{\ell}\right)$.
    В случае успеха участники удаляют $\{\sigma_{\ell}:1\leq\ell\leq n\}$.
    
\end{enumerate}

\textbf{Такт 2} 
\begin{enumerate}
    \item Каждый $P_{i}$ отправляет каждому другому участнику $P_{\ell}$ секретную долю $(\ell,f_{i}(\ell))$, удаляя $f_{i}$ и каждую последующую долю, за исключением $(i,f_{i}(i))$, которую они оставляют себе.
    
    \item Каждый $P_{i}$ проверяет свои доли, вычисляя: $g^{f_{\ell}(i)}\stackrel{{\text{?}}}{{=}}\prod_{k=0}^{t-1}\phi_{ik}^{s_{k}\bmod q}$, прерывая работу, если проверка не удалась.
    
   \item Каждый $P_{i}$ вычисляет свою долговременную секретную подпись, рассчитывая $s_{i}=\sum_{\ell=1}^{n}f_{\ell}(i)$, надежно сохраняет $s_{i}$ и удаляет каждый $f_{\ell}(i)$.
    
    \item Каждый $P_{i}$ вычисляет свою публичную проверочную часть $Y_{i}=g^{s_{i}}$, и общий публичный ключ группы $Y=\prod_{j=1}^{n}\phi_{j0}$. Любой участник может вычислить публичную проверочную часть любого другого участника, вычислив
    
    $$Y_{i}=\prod_{j=1}^{n}\prod_{k=0}^{t-1}\phi_{jk}^{s_{k}\bmod q}.$$
    
\end{enumerate}

\subsubsection{Стадия предварительной обработки}

В этом случае $\pi$ определяет количество генерируемых одноразовых кодов и соответствующих им обязательств, которые публикуются за один этап предварительной обработки. Реализации, не требующие кэширования обязательств, могут вместо этого использовать двухраундовый протокол подписания, где участники публикуют
одно обязательство друг перед другом в первом раунде.\\

{\centering\textbf{Предварительная обработка($\pi$) $\rightarrow$ $(i, \langle (D_{ij}, E_{ij}) \rangle_{j=1}^{\pi})$}\par}

Каждый участник $P_i, i \in \{1, \ldots, n\}$ выполняет этот этап перед подписанием. Пусть $j$ — счётчик для конкретной пары одноразовых данных/обязательных данных, а $\pi$ — количество пар, генерируемых одновременно, так что $\pi$ операций подписания могут быть выполнены до выполнения следующего этапа предварительной обработки.

\begin{enumerate}
\item Создадим пустой список $L_i$. Затем, для $1 \leq j \leq \pi$, выполним следующее:
    \begin{enumerate}[label=\alph*)]
    \item Выберем одноразовые случайные числа $(d_{ij}, e_{ij}) \overset{\$}{\leftarrow} \mathbb{Z}_q^* \times \mathbb{Z}_q^*$

    \item Выведем доли обязательств $(D_{ij}, E_{ij}) = (g^{d_{ij}}, g^{e_{ij}})$.

    \item Добавим $(D_{ij}, E_{ij})$ к $L_i$. Сохраним $((d_{ij}, D_{ij}), (e_{ij}, E_{ij}))$ для последующего использования в операциях подписания.
    \end{enumerate}

    \item Опубликуем $(i, L_i)$ в заранее определенном месте, как указано в реализации.
    
\end{enumerate}

\subsubsection{Протокол выработки подписи}

{\centering\textbf{Sign($m$) $\rightarrow$ $(m, \sigma)$}\par}

Пусть $\mathcal{SA}$ обозначает агрегатор подписей (который сам может быть одним из участников подписания). Пусть $S$ — множество из $\alpha:t\leq\alpha\leq n$ участников, выбранных для этой операции подписания, а $Y$ — открытый ключ группы. Пусть $B=\langle(i,D_{i},E_{i})\rangle_{i\in S}$ обозначает упорядоченный список индексов участников, соответствующих каждому участнику $P_{i}$, $s_{i}$ — общий секретный ключ $P_{i}$, а $L_{i}$ — множество значений обязательств для $P_{i}$, опубликованных на этапе предварительной обработки. Каждый идентификатор $i$ связан с обязательствами $(D_{i},E_{i})$, опубликованными $P_{i}$, которые будут использоваться для этой операции подписания. Пусть $H_{1},H_{2}$ будут хэш-функциями, выходные данные которых находятся в $\mathbb{Z}_{q}^{*}$.

\begin{enumerate}
    \item $\mathcal{SA}$ начинает с извлечения следующего доступного обязательства для каждого участника $P_{i}\in S$ из $L_{i}$ и построения $B$.
    
    \item Для каждого $i\in S$, $\mathcal{SA}$ отправляет $P_{i}$ кортеж $(m,B)$.
    
    \item После получения $(m,B)$ каждый $P_{i}$ сначала проверяет сообщение $m$, а затем проверяет $D_{\ell},E_{\ell}\in\mathbb{G}^{*}$ на предмет каждого обязательства в $B$, прерывая работу, если какая-либо проверка не удалась.
    
    \item Затем каждый $P_{i}$ вычисляет набор значений связывания $\rho_{\ell}=H_{1}(\ell,m,B),\ell\in S$. Затем каждый $P_{i}$ выводит групповое обязательство $R=\prod_{\ell\in S}D_{\ell}\cdot(E_{\ell})^{\rho_{\ell}}$ и вызов $c=H_{2}(R,Y,m)$.
    
    \item Каждый $P_{i}$ вычисляет свой ответ, используя свой долгоживущий секретный общий ресурс $s_{i}$, вычисляя $z_{i}=d_{i}+(e_{i}\cdot\rho_{i})+\lambda_{i}\cdot s_{i}\cdot c$, используя $S$ для определения $i\text{-ого}$ коэффициента Лагранжа $\lambda_{i}$.
    
    \item Каждый $P_{i}$ безопасно удаляет $((d_{i},D_{i}),(e_{i},E_{i}))$ из своего локального хранилища, а затем возвращает $z_{i}$ в $\mathcal{SA}$.
    
    \item Агрегатор подписей $\mathcal{SA}$ выполняет следующие шаги:
        \begin{enumerate}
            \item Выводит $\rho_{i}=H_{1}(i,m,B)$ и $R_{i}=D_{ij}\cdot(E_{ij})^{\rho_{i}}$ для $i\in S$, а затем $R=\prod_{i\in S}R_{i}$ и $c=H_{2}(R,Y,m)$.
            \item Проверяет корректность каждого ответа, проверяя $g^{z_{i}}\stackrel{?}{=}R_{i}\cdot Y_{i}^{\,c\cdot\lambda_{i}}$ для каждой доли подписи $z_{i}$, $i\in S$. Если равенство не выполняется, определяет участника, ведущего себя неподобающим образом, и сообщает об этом, а затем прерывает эксперимент. В противном случае продолжает.
            \item Вычисляет ответ группы $z=\sum z_{i}$
            \item Публикует $\sigma=(R,z)$ вместе с $m$.
        \end{enumerate}
\end{enumerate}

\subsection{Корректность}

Подписи в FROST строятся из двух многочленов; первый многочлен \( F_1(x) \) определяет секретное разделение закрытого ключа подписи \( s \) (такое, что \( Y = g^s \)) а второй многочлен \( F_2(x) \) определяет секретное разделение одноразового кода \( k \) такое, что \( k = \sum_{i \in S} d_i + e_i \cdot \rho_i \) используя связанные открытые данные \((m, B)\) для определения \(\rho_i\). Во время фазы генерации ключа первый многочлен \( F_1(x) = \sum_{j=1}^n f_j(x) \) генерируется таким образом, что доли секретного ключа равны \( s_i = F_1(i) \) и секретный ключ равен \( s = F_1(0) \).

Во время фазы подписи каждый из \( \alpha : t \leq \alpha \leq n \) участников, выбранных для подписания, использует пару одноразовых номеров \((d_i, e_i)\) для определения полинома степени \( \alpha - 1 \) \( F_2(x) \), интерполируя значения \((i, \frac{d_i + e_i \cdot H_1(i,m,B)}{\lambda_i})\), такие, что \( F_2(0) = \sum_{i \in S} d_i + e_i \cdot \rho_i \).

Тогда пусть \( F_3(x) = F_2(x) + c \cdot F_1(x) \), где \( c = H_2(R, Y, m) \). Теперь \( z_i \) равно \( d_i + (e_i \cdot \rho_i) + \lambda_i \cdot s_i \cdot c = \lambda_i(F_2(i) + c \cdot F_1(i)) = \lambda_i F_3(i) \), поэтому \( z = \sum_{i \in S} z_i \) — это просто интерполяция Лагранжа для \( F_3(0) = (\sum_{i \in S} d_i + e_i \cdot \rho_i) + c \cdot s \). Поскольку \( R = g^{\sum_{i \in S} d_i + e_i \cdot \rho_i} \) и \( c = H_2(R, Y, m) \), \((R, z)\) является правильной подписью Шнорра для \( m \).

\subsection{Надёжность}

FROST требует от участников прерывания сеанса после обнаружения некорректного поведения, что позволяет сократить количество раундов коммуникации в честной обстановке. Если один из участников предоставляет некорректную подпись, $\mathcal{SA}$ обнаружит это и прервет протокол, если сам $\mathcal{SA}$ ведет себя корректно. Протокол можно запустить повторно, удалив нарушителя. Если сам $\mathcal{SA}$ ведет себя некорректно, и даже если до $t - 1$ участников были повреждены, $\mathcal{SA}$ все равно не сможет создать действительную подпись для сообщения, не одобренного хотя бы одним честным участником.

\subsection{Безопасность}

Данная схема выработки пороговой подписи Шнорра безопасна, так как задача "единичная подделка" в схеме ROM \cite{ROM} для неё сапоставима по сложности с задачей дискретного логарифмирования в подгруппе, порождённой $G$. Более того справедлива следующая теорема:

\begin{theorem}
    Если задача дискретного логарифмирования в \(\mathbb{G}\) является \((\tau^{\prime},\varepsilon^{\prime})\)-трудной, то схема подписи FROST-Interactive над \(\mathbb{G}\) с \(n\) подписывающими участниками, порогом \(t\) и размером пакета предварительной обработки \(\pi\) является \((\tau,n_{h},n_{p},n_{s},\varepsilon)\)-безопасной всякий раз, когда

    \[
    \varepsilon^{\prime}\leq\frac{\varepsilon^{2}}{2n_{h}+(\pi+1)n_{p}+1}\quad\text{and}
    \]

    \[
    \tau^{\prime}=4\tau+(30\pi n_{p}+(4t-2)n_{s}+(n+t-1)t+6)\cdot t_{exp}+O(\pi n_{p }+n_{s}+n_{h}+1)
    \]

    таким образом, что \(t_{exp}\) — это время возведения в степень в \(\mathbb{G}\), предполагая, что количество участников, скомпрометированных злоумышленником, меньше порогового значения \(t\).
\end{theorem}

В простом FROST злоумышленник может запрашивать случайный оракул \(\rho_{i}=H_{1}(i,m,B)\) полиномиально много раз, даже с одним и тем же \((i,D_{i},E_{i})\in B\). Злоумышленник сможет создать подделку, если (слегка обобщая атаку Дрейверса на произвольные линейные комбинации, а не просто суммы) он сможет найти \(m^{*}\), \(r^{*}\) и \(\langle m_{j},B_{j},\gamma_{j}\rangle_{j=1}^{\pi}\) такие, что

\[
\begin{split}
& H_{2}(R^{*},Y,m^{*})=\sum_{j=1}^{\pi}\gamma_{j} \cdot H_{2}(R_{j},Y,m_{j})
\end{split}
\tag{1}
\]

где \(R_{j}=\prod_{(i,D,E)\in B_{j}}D\cdot E^{H_{1}(i,m_{j},B_{j})}\), \(\widehat{R_{j}}=D_{jt}\cdot E_{jt}^{H_{1}(i,m_{j},B_{j})}\), \(R^{*}=g^{r^{*}}\cdot\prod_{j=1}^{\pi}\widehat{R_{j}}^{\gamma_{j}}\), каждый \(B_{j}\) содержит \((t,D_{jt},E_{jt})\), и \(m^{*}\) не является одним из \(m_{j}\).

Важно отметить, что ключевое отличие FROST от схем, подверженных атаке Дрейверса \cite{Dr}, заключается в том, что во FROST $ R^* $ в левой части уравнения (1) сама по себе является функцией всех входных данных хэш-функций в правой части. Дрейверс может использовать обобщенную атаку дней рождений Вагнера \cite{BD}, поскольку левая и правая части Уравнения 1 независимы для схем, уязвимых к его атаке, и поэтому алгоритм Вагнера может найти коллизию между списком возможных значений слева (термины $(m^*, R^*)$) и (более большим) списком возможных значений справа (термины $(m_j, R_j)$). Однако во FROST каждая комбинация значений справа \textit{изменяет} $ R^* $, и поэтому список возможных значений слева (например, изменяющийся $ m^* $) изменяется для каждой такой комбинации, увеличивая для злоумышленника стоимость атаки на коллизию дней рождения по сравнению с атаками с несколькими прообразами.

\chapter{Сравнение существующих реализаций}
\section{Сравнение реализации}

\subsection{Протокол выработки подписи}

Работа обоих протоколов начинается с генерации ключа по схеме Педерсена, однако важно, что FROST дополнительно предусматривает защиту от атаки с неверным ключом. Протокол Стинсона и Стробла не просто так требует целых три такта для генерации ключа, он тоже частично решает эту проблему. Доказано, что, если хотя бы половина участников протокола честны, то честные подписанты сгенерируют свои части корректно. 

Ещё одним важным иструментом, применённым в протоколе FROST, является схема обязательств. Это криптографический примитив, который позволяет зафиксировать какое-либо выбранное значение (выбранное утверждение, бит информации), сохраняя его скрытым для других, с возможностью позже раскрыть зафиксированное значение. Схемы обязательств разработаны таким образом, что сторона не может изменить значение или утверждение после отправки, то есть схемы обязательств реализуют связывание данных. В схеме Стинсона и Стробла подразумевается, что предъявляемые на протяжении работы протокола данные - доказательства с нулевым разглашением, так что реализация их в виде обязательств не требуется.

А вот использование в FROST агрегатора подписей как раз помогает снять с участников часть работы, так как при его использовании исчезает необходимость обмена информацией всех со всеми, что как раз и позволяет процессам выполняться асинхронно (ввиду чего возникает угроза атаки Дрейверса). Хотя стоит заметить, что реализация Стинсона и Стробла тоже легко адаптируется под протокол с участием доверенного дилера, однако потом участники не смогут выработать подписи без него. 

\subsection{Автономность участников}

Важным улучшением, привнесённым в протокол FROST является то, что раунд предварительной обработки может быть выполнен отдельно от раунда подписания, операции подписания могут выполняться асинхронно; после завершения раунда предварительной обработки подписывающим достаточно получить и в конечном итоге ответить одним сообщением для создания подписи. Более того, хотя некоторые пороговые схемы, в частности реализация Стинсона и Стробла, требуют, чтобы все участники были активны во время операций подписания, и называют пороговое свойство протокола просто свойством безопасности, FROST позволяет любому пороговому количеству участников создавать действительные подписи. Следовательно, FROST может поддерживать сценарии использования, когда подмножество участников (или участвующих устройств) может оставаться в автономном режиме, что часто желательно для обеспечения безопасности на практике.

\subsection{Количество тактов генерации ключа}

FROST может использоваться как двухэтапный протокол, где подписанты отправляют и получают всего два сообщения, или как оптимизированный
(нешироковещательный) одноэтапный протокол подписания с этапом предварительной обработки. В любом случае это быстрее, чем протокол Стинсона и Стробла, который всегда требует три такта, однако тут встаёт вопрос надёжности. Для FROST мы вынуждены перезапускать протокол при обнаружении обмана среди участников, тогда как протокол Стинсона и Стробла в такой ситуации работает без прерываний. Так что при достаточном количестве нечестных подписантов FROST не будет давать заявленного выйгрыша.

\section{Сравнение надёжности}

Реализация Стинсона и Стробла является классическим примером надёжной схемы, то есть при небольшом количестве нечестных подписантов протокол доработает до конца и успешно сгенерирует подпись. FROST же прелагает пожертвовать надёжностью в угоду эффективности, то есть при попытке жульничества протокол прерывает свою работу и предлагает начать с начала. Так что максимальная эффективность будет достижима только, если все участники честны.

\section{Сравнение безопастности}

В обоих случаях используется похожий подход для доказательства безопасности: в первом случае это сравнение сложности взлома со сложностью взлома схемы Шнорра, что в свою очередь сравнимо с решением проблемы дискретного логарифмирования, во втором случае сложность сразу сравнивают с проблемой дискретного логарифмироваия. Так как в общем случае не доказано, что задача дискретного логарифмирования так же трудна, как и взлом схемы Шнорра, то обходятся доказательством редукции в так называемой моделе ROM \cite{ROM}. Основным инструментом в доказательсте безопастности является лемма о разветвлении. Давайте сравним результаты теоремы 2.4 и те же результаты для обычной подписи Шнорра \cite{ROM} (которые согласно теоремам 2.2 и 2.3 можно применять и для протокола Стинсона и Стробла).  

\begin{theorem}
    Если задача дискретного логарифмирования в \(\mathbb{G}\) является \((\tau^{\prime},\varepsilon^{\prime})\)-трудной, то схема подписи FROST-Interactive над \(\mathbb{G}\) с \(n\) подписывающими участниками, порогом \(t\) и размером пакета предварительной обработки \(\pi\) является \((\tau,n_{h},n_{p},n_{s},\varepsilon)\)-безопасной всякий раз, когда

    \[
    \varepsilon^{\prime}\leq\frac{\varepsilon^{2}}{2n_{h}+(\pi+1)n_{p}+1}\quad\text{and}
    \]

    \[
    \tau^{\prime}=4\tau+(30\pi n_{p}+(4t-2)n_{s}+(n+t-1)t+6)\cdot t_{exp}+O(\pi n_{p }+n_{s}+n_{h}+1)
    \]

    таким образом, что \(t_{exp}\) — это время возведения в степень в \(\mathbb{G}\), предполагая, что количество участников, скомпрометированных злоумышленником, меньше порогового значения \(t\).
\end{theorem}

\begin{lemma}
    Пусть полиномиальный алгоритм $A$ с вероятностью \textbf{Adv}($A$) $> 1 - \frac{1}{2^l}$ решает задачу Schnorr (задача "единичной подделки" подписи Шнорра) в моделе ROM, используя $\beta_H$ обращений к оракулу $\mathcal{H}$ и $\beta_S$ обращений к оракулу $\mathcal{S}$. Пусть
    $$ \varepsilon = \frac{\beta_H \beta_S + \beta_S(\beta_S + 1)/2}{q} < 1. $$
    Тогда существует алгоритм $B$, который с вероятностью 
    $$ \textbf{Adv}(B) \geq \left( \frac{\textbf{Adv}(A) - 1/2^l}{2\beta_H} \right)^3(1 - \varepsilon)^2 $$
    решает задачу дискретного логарифмирования, используя два обращения к $A$ и ещё $O(\beta_H + \beta_S)$ операций.
\end{lemma}

В обоих случаях оценки достаточно близки, так что можем считать обе схемы одинаково безопастными.